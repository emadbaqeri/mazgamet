name: Auto-Tag on Main

on:
  push:
    branches:
      - main
  workflow_dispatch:
    inputs:
      version_increment:
        description: 'Version increment type (patch, minor, major)'
        required: true
        default: 'patch'
        type: choice
        options:
          - patch
          - minor
          - major

jobs:
  auto-tag:
    name: Auto-Tag Latest Commit
    runs-on: ubuntu-latest
    # Don't run this job if the push was already tagged
    if: '!startsWith(github.ref, "refs/tags/")'
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Set Git User
        run: |
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"

      - name: Get current version
        id: current_version
        run: |
          # Try to get version from workspace.package first
          if grep -q '\[workspace\.package\]' mazgamet/Cargo.toml; then
            CURRENT_VERSION=$(grep -A10 '\[workspace\.package\]' mazgamet/Cargo.toml | grep -oP 'version = "\K[^"]+' | head -1 || echo "0.1.0")
          else
            # Fallback to lexer Cargo.toml
            CURRENT_VERSION=$(grep -oP 'version = "\K[^"]+' mazgamet/lexer/Cargo.toml | head -1 || echo "0.1.0")
          fi
          
          echo "current_version=$CURRENT_VERSION" >> $GITHUB_OUTPUT
          echo "::notice::Current version is $CURRENT_VERSION"

      - name: Get latest tag
        id: latest_tag
        run: |
          # Get the latest tag if it exists
          LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "none")
          
          # If no tag exists, use v0.0.0 as the base for comparison
          if [ "$LATEST_TAG" == "none" ]; then
            LATEST_TAG="v0.0.0"
            echo "::notice::No previous tags found, using $LATEST_TAG as base"
          else
            echo "::notice::Latest tag is $LATEST_TAG"
          fi
          
          echo "latest_tag=$LATEST_TAG" >> $GITHUB_OUTPUT

      - name: Determine new version
        id: new_version
        run: |
          CURRENT_VERSION="${{ steps.current_version.outputs.current_version }}"
          LATEST_TAG="${{ steps.latest_tag.outputs.latest_tag }}"
          
          # Remove 'v' prefix if exists
          LATEST_VERSION="${LATEST_TAG#v}"
          
          # Parse version components
          IFS='.' read -r -a VERSION_PARTS <<< "$CURRENT_VERSION"
          MAJOR=${VERSION_PARTS[0]:-0}
          MINOR=${VERSION_PARTS[1]:-0}
          PATCH=${VERSION_PARTS[2]:-0}
          
          # Determine version increment type
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            INCREMENT_TYPE="${{ github.event.inputs.version_increment }}"
          else
            # Auto-detect if commits contain breaking changes or features
            LAST_COMMIT_MSG=$(git log -1 --pretty=%B)
            if [[ "$LAST_COMMIT_MSG" == *"BREAKING CHANGE"* ]] || [[ "$LAST_COMMIT_MSG" == "break:"* ]]; then
              INCREMENT_TYPE="major"
            elif [[ "$LAST_COMMIT_MSG" == "feat:"* ]]; then
              INCREMENT_TYPE="minor"
            else
              INCREMENT_TYPE="patch"
            fi
          fi
          
          # Increment version based on type
          case "$INCREMENT_TYPE" in
            major)
              NEW_VERSION="$((MAJOR + 1)).0.0"
              echo "::notice::Major version bump detected"
              ;;
            minor)
              NEW_VERSION="$MAJOR.$((MINOR + 1)).0"
              echo "::notice::Minor version bump detected"
              ;;
            patch|*)
              NEW_VERSION="$MAJOR.$MINOR.$((PATCH + 1))"
              echo "::notice::Patch version bump detected"
              ;;
          esac
          
          # Check if new version is greater than the current Cargo.toml version
          # Compare lexicographically which works for semver
          # If new version is greater than or equal to current version, use the new version
          # Otherwise, use the current version + patch
          if [ "$(printf '%s\n' "$LATEST_VERSION" "$CURRENT_VERSION" | sort -V | head -n1)" = "$LATEST_VERSION" ] && \
             [ "$LATEST_VERSION" != "$CURRENT_VERSION" ]; then
            # Latest tag version is less than the current Cargo.toml version, so use current + patch
            if [ "$INCREMENT_TYPE" == "patch" ]; then
              echo "::notice::Using current version + patch: $NEW_VERSION"
            else 
              echo "::notice::Using calculated new version: $NEW_VERSION"
            fi
          else
            # Latest tag version is already at or greater than Cargo.toml, just increment the tag
            IFS='.' read -r -a TAG_PARTS <<< "$LATEST_VERSION"
            TAG_MAJOR=${TAG_PARTS[0]:-0}
            TAG_MINOR=${TAG_PARTS[1]:-0}
            TAG_PATCH=${TAG_PARTS[2]:-0}
            
            case "$INCREMENT_TYPE" in
              major)
                NEW_VERSION="$((TAG_MAJOR + 1)).0.0"
                ;;
              minor)
                NEW_VERSION="$TAG_MAJOR.$((TAG_MINOR + 1)).0"
                ;;
              patch|*)
                NEW_VERSION="$TAG_MAJOR.$TAG_MINOR.$((TAG_PATCH + 1))"
                ;;
            esac
            echo "::notice::Incrementing from latest tag to: $NEW_VERSION"
          fi
          
          echo "new_version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "new_tag=v$NEW_VERSION" >> $GITHUB_OUTPUT

      - name: Update version in Cargo.toml files
        run: |
          NEW_VERSION="${{ steps.new_version.outputs.new_version }}"
          
          # Update workspace Cargo.toml
          if grep -q '\[workspace\.package\]' mazgamet/Cargo.toml; then
            sed -i "s/version = \"[^\"]*\"/version = \"$NEW_VERSION\"/" $(grep -l '\[workspace\.package\]' mazgamet/Cargo.toml)
            echo "::notice::Updated workspace package version to $NEW_VERSION"
          fi
          
          # Update all package Cargo.toml files
          for toml in $(find mazgamet -name Cargo.toml); do
            if grep -q '\[package\]' "$toml"; then
              sed -i "s/version = \"[^\"]*\"/version = \"$NEW_VERSION\"/" "$toml"
              echo "::notice::Updated version in $toml to $NEW_VERSION"
            fi
          done

      - name: Update CHANGELOG.md
        run: |
          NEW_VERSION="${{ steps.new_version.outputs.new_version }}"
          NEW_TAG="${{ steps.new_version.outputs.new_tag }}"
          TODAY=$(date +'%Y-%m-%d')
          CHANGELOG_PATH="mazgamet/CHANGELOG.md"
          
          # Create CHANGELOG.md if it doesn't exist
          if [ ! -f "$CHANGELOG_PATH" ]; then
            echo "# Changelog" > "$CHANGELOG_PATH"
            echo "" >> "$CHANGELOG_PATH"
          fi
          
          # Check if Unreleased section exists
          if grep -q "## Unreleased" "$CHANGELOG_PATH"; then
            # Convert Unreleased section to version section
            sed -i "s/## Unreleased/## $NEW_TAG ($TODAY)/" "$CHANGELOG_PATH"
            # Add a new Unreleased section at the top
            sed -i "s/# Changelog/# Changelog\n\n## Unreleased\n/" "$CHANGELOG_PATH"
          else
            # Add new version section right after the header
            sed -i "s/# Changelog/# Changelog\n\n## $NEW_TAG ($TODAY)\n\n### Added\n- Auto-generated release/" "$CHANGELOG_PATH"
            # Add Unreleased section at the top
            sed -i "s/# Changelog/# Changelog\n\n## Unreleased\n/" "$CHANGELOG_PATH"
          fi
          
          echo "::notice::Updated CHANGELOG.md with new version $NEW_TAG"

      - name: Commit and push version updates
        run: |
          NEW_VERSION="${{ steps.new_version.outputs.new_version }}"
          
          git add mazgamet/Cargo.toml mazgamet/*/Cargo.toml mazgamet/CHANGELOG.md
          git commit -m "chore: bump version to $NEW_VERSION [skip ci]"
          git push
          
          echo "::notice::Committed and pushed version updates"

      - name: Create and push tag
        run: |
          NEW_TAG="${{ steps.new_version.outputs.new_tag }}"
          
          git tag "$NEW_TAG"
          git push origin "$NEW_TAG"
          
          echo "::notice::Created and pushed tag $NEW_TAG"